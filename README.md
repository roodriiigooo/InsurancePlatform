# Plataforma de Seguros - Arquitetura Hexagonal e CQRS

Este reposit√≥rio cont√©m a implementa√ß√£o de uma plataforma de seguros simplificada, desenvolvida com uma arquitetura moderna e robusta baseada em Microservi√ßos, DDD, Arquitetura Hexagonal e CQRS.

O projeto permite criar e gerenciar propostas de seguro. Quando uma proposta √© aprovada, um evento √© disparado para que o servi√ßo de contrata√ß√£o processe a efetiva√ß√£o do seguro de forma ass√≠ncrona.


````
+--------------------------------------------------------------------------------------------------+
|  üè¶ Plataforma de Seguros                                                                        |
+--------------------------------------------------------------------------------------------------+
|                                                                                                  |
|   Propostas de Seguro                                                        [ + Nova Proposta ] |
|  +---------------------------------------------------------------------------------------------+ |
|  | NOME DO CLIENTE ‚ñæ | VALOR DO SEGURO |    STATUS    |      MENSAGEM   |          A√á√ïES       | |
|  |-------------------+-----------------+--------------+-----------------|----------------------+ |
|  | Jo√£o da Silva     | R$ 2.500,00     | [ Aprovada ] |                 | [Editar]             | |
|  |-------------------+-----------------+--------------+-----------------|----------------------+ |
|  | Maria Oliveira    | R$ 1.800,00     | [Em An√°lise] |                 | [Aprovar][Rejeitar]| | |
|  |-------------------+-----------------+--------------+-----------------|----------------------+ |
|  | Pedro Martins     | R$ 3.200,00     | [ Rejeitada ]|                 |                      | |
|  +----------------------------------------------------------------------+----------------------+ |
|                                                                                                  |
+--------------------------------------------------------------------------------------------------+
````


Keywords: `Microservi√ßos` `Arquitetura Hexagonal` `DDD` `CQRS` `MediatR` `C#` `.NET 8` `ASP.NET Core` `APIs REST` `Blazor WebAssembly (Standalone)` `Entity Framework Core` `Dapper` `Mensageria` `RabbitMQ` `MassTransit` `SQL Server` `Migrations` `xUnit` `Teste unit√°rio` `FluentAssertions` `Moq` `Docker` `Docker Compose`


## :books: Arquitetura e Tecnologias

A solu√ß√£o √© composta por uma aplica√ß√£o web e dois microservi√ßos de backend, orquestrados para rodar em cont√™ineres `Docker`.

* **Padr√µes de Arquitetura**: `Microservi√ßos`, `Arquitetura Hexagonal (Ports & Adapters)`, `DDD`, `CQRS` com `MediatR`.
* **Backend**: `C#` com `.NET 8`, `ASP.NET Core` para APIs REST.
* **Frontend**: `Blazor WebAssembly (Standalone)`.
* **Persist√™ncia**:
    * **`EF Core`**: Para o lado de escrita (Commands), garantindo consist√™ncia e regras de neg√≥cio.
    * **`Dapper`**: Para o lado de leitura (Queries), garantindo m√°xima performance.
* **Mensageria**: `RabbitMQ` para comunica√ß√£o ass√≠ncrona entre os servi√ßos, `MassTransit` (abstra√ß√£o para mensageria no .NET).
* **Banco de Dados**: `SQL Server` com uso de `Migrations`.
* **Testes**: `xUnit` (framework de testes), `FluentAssertions` (para asser√ß√µes leg√≠veis), `Moq` (para mocking de depend√™ncias)
* **Containeriza√ß√£o**: `Docker` e `Docker Compose`.

### Diagrama da Arquitetura Final

O diagrama abaixo ilustra a intera√ß√£o entre todos os componentes do sistema, representando a arquitetura final:

```mermaid
graph TD
    subgraph "Cliente (Swagger / Postman / WebApp)"
        User["Usu√°rio"]
    end

    subgraph PropostaService ["PropostaService (Porta 8080)"]
        style PropostaService fill:#e3f2fd,stroke:#333,stroke-width:2px
        Controller_P["API REST <br> PropostasController"]
        Mediator_P["MediatR"]
        Commands["Handlers de Comando <br> Criar, Aprovar, etc. <br> Usando EF Core"]
        Queries_P["Handlers de Query <br> Listar <br> Usando Dapper"]
        Publisher["Publicador de Eventos <br> MassTransit"]
        
        Controller_P -- Envia Command/Query --> Mediator_P
        Mediator_P --> Commands
        Mediator_P --> Queries_P
        Commands -- Dispara Evento --> Publisher
    end

    subgraph ContratacaoService ["ContratacaoService (Worker e API)"]
        style ContratacaoService fill:#e8f5e9,stroke:#333,stroke-width:2px
        
        %% Adicionando o fluxo de API que faltava %%
        Controller_C["API REST <br> ContratacoesController"]
        Mediator_C["MediatR"]
        Queries_C["Handlers de Query <br> (Listar) <br> Usando Dapper"]
        
        %% Componentes de Worker existentes %%
        Consumer["Consumidor de Eventos <br> MassTransit"]
        Logic["L√≥gica de Contrata√ß√£o <br> Usando EF Core"]
        
        Controller_C -- Envia Query --> Mediator_C
        Mediator_C --> Queries_C
        Consumer --> Logic
    end
    
    subgraph Infra ["Infraestrutura Compartilhada"]
        style Infra fill:#fbe9e7,stroke:#333,stroke-width:2px
        DB[("SQL Server DB")]
        RabbitMQ["RabbitMQ <br> Fila: contratacao-queue"]
    end
    
    %% Conex√µes do Cliente %%
    User -- Requisi√ß√£o HTTP para Propostas --> Controller_P
    User -- Requisi√ß√£o HTTP para Contrata√ß√µes --> Controller_C

    %% Conex√µes do PropostaService %%
    Commands -- Salva/Altera Proposta --> DB
    Queries_P -- L√™ Propostas --> DB
    Publisher -- Publica Mensagem --> RabbitMQ
    
    %% Conex√µes do ContratacaoService %%
    RabbitMQ -- Entrega Mensagem --> Consumer
    Logic -- Salva Contrata√ß√£o --> DB
    Queries_C -- L√™ Contrata√ß√µes --> DB
```

<details>
	<summary> Se n√£o for possivel visualizar o diagrama, clique aqui</summary>

![Diagrama da Arquitetura Final](https://github.com/roodriiigooo/InsurancePlatform/blob/main/.assets/_Mermaid_Chart-2025-08-28-183320.png?raw=true)

 
</details>



## Descric√£o geral do projeto


üìå O que √© o sistema?

O sistema √© uma aplica√ß√£o distribu√≠da para gest√£o de propostas e contrata√ß√µes.
Ele √© composto por dois servi√ßos principais (`PropostaService` e `ContratacaoService`) que interagem via mensageria (`RabbitMQ`) e usam um banco de dados SQL Server como persist√™ncia compartilhada.

A ideia central:
O usu√°rio (via `Swagger`, `Postman` ou `WebApp`) faz requisi√ß√µes para criar, aprovar ou consultar propostas.
As propostas geram eventos que disparam um fluxo de contrata√ß√£o ass√≠ncrono, tratado por outro servi√ßo.

üìå Arquitetura geral

O sistema segue princ√≠pios de arquitetura em camadas e comunica√ß√£o ass√≠ncrona.
Temos tr√™s blocos principais:

	 1. Cliente (Swagger / Postman / WebApp)
 		- Onde o usu√°rio interage via requisi√ß√µes HTTP.
   		- Pode ser um sistema externo, um frontend ou ferramenta de testes.
	 2. Servi√ßos de Neg√≥cio
  		- PropostaService (porta 8080)
			- Camada exposta via API REST.
   			- Respons√°vel por criar, aprovar e consultar propostas.
	  		- Usa MediatR para aplicar o padr√£o CQRS (separa√ß√£o de comandos e queries).
	 		  - Commands (handlers de escrita) ‚Üí usam EF Core para salvar/alterar propostas.
	  		  - Queries (handlers de leitura) ‚Üí usam Dapper para consultas otimizadas.
	   		- Quando ocorre uma altera√ß√£o relevante (ex: aprova√ß√£o de proposta), um evento √© publicado via MassTransit para o RabbitMQ.
	    - ContratacaoService (Worker)
	 		- Exp√µe API HTTP (para melhor visualiza√ß√£o), por√©m √© um servi√ßo background (worker).
			- Consome eventos do RabbitMQ (ex: "PropostaAprovada").
   			- Processa a l√≥gica de contrata√ß√£o usando EF Core.
	  		- Persiste as informa√ß√µes de contrata√ß√£o no mesmo SQL Server.
	 3. Infraestrutura Compartilhada
  		- Banco de Dados (SQL Server)
			- Usado tanto para propostas quanto para contrata√ß√µes.
   		- RabbitMQ
	 		- Fila "contratacao-queue" que transporta mensagens/eventos entre os servi√ßos.

üìå Fluxo resumido (exemplo: criar e aprovar proposta):

- O usu√°rio envia uma requisi√ß√£o `HTTP` (`POST` /propostas).
- A `API REST` (`Controller`) recebe e envia o comando ao Mediator.
- O Mediator encaminha para o handler de Command (`EF Core`) que grava a proposta no banco.
- Quando a proposta √© aprovada, o handler dispara um evento para o Publisher (`MassTransit`).
- O Publisher envia o evento para o `RabbitMQ`.
- O Consumer (`ContratacaoService`) recebe a mensagem.
- O ContratacaoService executa a l√≥gica de contrata√ß√£o e grava no banco (`EF Core`).
- O fluxo se conclui de forma ass√≠ncrona, sem bloquear a experi√™ncia do usu√°rio.


üìå Padr√µes e boas pr√°ticas aplicadas

`CQRS` (Command Query Responsibility Segregation):
- Separa√ß√£o clara entre opera√ß√µes de escrita (`Commands + EF Core`) e leitura (`Queries + Dapper`).

Mediator Pattern (via `MediatR`):
- Evita que os Controllers chamem diretamente os handlers, centralizando a orquestra√ß√£o.

`Event-driven Architecture` (`EDA`):
- A contrata√ß√£o √© disparada por eventos publicados no `RabbitMQ`, promovendo baixo acoplamento entre servi√ßos.

`MassTransit`:
- Abstrai a comunica√ß√£o com o `RabbitMQ`, simplificando publica√ß√£o e consumo de mensagens.

Banco relacional centralizado (`SQL Server`):
- Usado como persist√™ncia confi√°vel, tanto para propostas quanto contrata√ß√µes.


üìå Benef√≠cios dessa arquitetura

Escalabilidade:
- O PropostaService pode escalar horizontalmente para atender mais requisi√ß√µes HTTP.
- O ContratacaoService pode escalar para consumir mais mensagens da fila.

Resili√™ncia:
- Se o ContratacaoService estiver fora do ar, as mensagens ficam retidas no RabbitMQ at√© ele voltar.

Separa√ß√£o de responsabilidades:
- PropostaService ‚Üí gest√£o de propostas.
- ContratacaoService ‚Üí fluxo de contrata√ß√£o.

Flexibilidade:
- F√°cil adicionar novos consumidores de eventos no futuro (ex: faturamento, notifica√ß√£o, auditoria).


üëâ Em resumo:
O sistema √© uma aplica√ß√£o orientada a eventos, que aplica CQRS para manipula√ß√£o de dados e usa RabbitMQ + MassTransit para integra√ß√£o ass√≠ncrona entre servi√ßos. Ele garante desacoplamento, escalabilidade e manutenibilidade, sendo ideal para cen√°rios de alto volume de propostas e contrata√ß√µes.



üìå Fluxo narrado
- O usu√°rio chama `POST` `/api/propostas` ‚Üí cria proposta pendente no banco.
- O usu√°rio chama `POST` `/api/propostas/{id}/aprovar`.
- O handler muda status para "Aprovada".
- Publica evento PropostaAprovadaEvent no `RabbitMQ`.
- O ContratacaoService consome o evento da fila.
- Cria uma nova Contrata√ß√£o no banco.
- Se o usu√°rio quiser consultar, chama `GET` `/api/propostas` e o `Dapper` retorna os registros.




## :books: Pr√©-requisitos

> [!IMPORTANT]
> Para executar este projeto, voc√™ precisar√° ter instalado:

* [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0)
* [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/) (ou outra IDE de sua prefer√™ncia)
* [Docker Desktop](https://www.docker.com/products/docker-desktop/)
* [Postman](https://www.postman.com/downloads/) (opcional para testes de API)


## Estrutura do Projeto

O projeto est√° organizado da seguinte forma:
```
/docker-compose.yml
/InsurancePlatform.sln
/src
|-- PropostaService
|   |-- PropostaService.Api/              (Driving Adapter: Controllers, Program.cs)
|   |-- PropostaService.Application/      (Application Core: Use Cases, DTOs, Ports)
|   |-- PropostaService.Domain/           (Domain Core: Entities, Enums, Business Rules)
|    `-- PropostaService.Infrastructure/  (Driven Adapters: Repository, EF Core)
|
`-- ContratacaoService
|   |-- ContratacaoService.Api/
|   |-- ContratacaoService.Application/
|   |-- ContratacaoService.Domain/
|    `--ContratacaoService.Infrastructure/
|
`-- Shared
|   |-- InsurancePlatform.Contracts
|    `-- InsurancePlatform.Shared
|
`-- WebApp
|   `-- InsurancePlatform.WebApp
|
`-- tests
|-- | -- PropostaService.UnitTests/
     `-- ContratacaoService.UnitTests/
```



# :writing_hand: Como Executar o Projeto Completo

**Primeiro clone o reposit√≥rio**

```powershell
git clone https://github.com/roodriiigooo/InsurancePlatform.git
cd InsurancePlatform
```


## :bookmark_tabs: **Op√ß√£o 1**: Ambiente Completo com Docker Compose
> [!TIP]
> A maneira mais simples e recomendada de executar toda a stack √© utilizando Docker Compose.


1.  **Inicie os cont√™ineres**
    Na raiz do projeto (onde o arquivo `docker-compose.yml` est√° localizado), execute o seguinte comando:
    ```powershell
    docker-compose up --build -d
    ```
    O comando `--build` garante que as imagens Docker para os seus servi√ßos ser√£o constru√≠das. Na primeira vez, isso pode levar alguns minutos.

2.  **Acesse os Servi√ßos**
ap√≥s a conclus√£o do build e a inicializa√ß√£o dos cont√™ineres, os servi√ßos estar√£o dispon√≠veis nos seguintes endere√ßos:

    * üåê **Aplica√ß√£o Web (Frontend)**: [http://localhost:8082](http://localhost:8082)
    * ‚öôÔ∏è **API do PropostaService**: [http://localhost:8080](http://localhost:8080) / [http://localhost:8080/swagger/index.html](http://localhost:8080/swagger/index.html) 
	* ‚öôÔ∏è **API do ContratacoService**: [http://localhost:8081](http://localhost:8081) / [http://localhost:8081/swagger/index.html](http://localhost:8081/swagger/index.html) 
    * üêá **RabbitMQ Management UI**: [http://localhost:15672](http://localhost:15672) (login: `guest` / senha: `guest`)



## :bookmark_tabs: **Op√ß√£o 2**: Ambiente H√≠brido (Debug com Visual Studio)
> [!TIP]
> Esta abordagem √© ideal para o desenvolvimento e depura√ß√£o do c√≥digo .NET.


1. **Inicie a Infraestrutura**: Abra um terminal na pasta raiz do projeto e inicie o banco de dados e o RabbitMQ em segundo plano com o Docker:

````powershell
docker-compose up -d proposta-db rabbitmq
````

2. **Abra no Visual Studio**: Abra o arquivo `InsurancePlatform.sln` no `Visual Studio`.
3. **Configure a Inicializa√ß√£o M√∫ltipla:**
   - Clique com o bot√£o direito na Solu√ß√£o > "**Definir Projetos de Inicializa√ß√£o...**"
   - Marque "V√°rios projetos de inicializa√ß√£o".
   - Defina a A√ß√£o como "Iniciar" para os tr√™s projetos: `PropostaService.Api`, `ContratacaoService.Api` e `InsurancePlatform.WebApp`.
4. **Execute**: Pressione `F5` ou o bot√£o "`Iniciar`". O Visual Studio ir√° compilar e iniciar os tr√™s projetos.

5.  **Acesse os Servi√ßos**
ap√≥s a conclus√£o do build e a inicializa√ß√£o dos cont√™ineres, os servi√ßos estar√£o dispon√≠veis nos seguintes endere√ßos:

    * üåê **Aplica√ß√£o Web (Frontend)**: [http://localhost:7189](http://localhost:7189)
    * ‚öôÔ∏è **API do PropostaService**: [http://localhost:7999](http://localhost:7999) / [http://localhost:7999/swagger/index.html](http://localhost:7999/swagger/index.html) 
	* ‚öôÔ∏è **API do ContratacoService**: [http://localhost:7285](http://localhost:7285) / [http://localhost:7285/swagger/index.html](http://localhost:7285/swagger/index.html) 
    * üêá **RabbitMQ Management UI**: [http://localhost:15672](http://localhost:15672) (login: `guest` / senha: `guest`)

> [!NOTE]
> A WebApp estar√° acess√≠vel no seu endere√ßo de debug (ex: https://localhost:7189).
> A API do PropostaService estar√° no seu endere√ßo de debug (ex: https://localhost:7999).
> A API do ContratacaoService estar√° no seu endere√ßo de debug (ex: https://localhost:7285).


# :page_with_curl: Como Executar os Testes Unit√°rios

Para rodar a su√≠te de testes unit√°rios, execute o seguinte comando na raiz do projeto:
```bash
dotnet test
```
ou no `Visual Studio`, v√° em `Teste` > `Executar todos os Testes`


# :art: Screenshots
<details>
	<summary># 1. WebApp</summary>

 
![WebApp](https://github.com/roodriiigooo/InsurancePlatform/blob/main/.assets/_WebAPP.PNG?raw=true)


</details>

<details>
	<summary># 2. Testes</summary>

 
![Testes](https://github.com/roodriiigooo/InsurancePlatform/blob/main/.assets/_tests.PNG?raw=true)


</details>

 
<details>
	<summary># 3. PropostaService.Api</summary>
 
![PropostaService.Api](https://github.com/roodriiigooo/InsurancePlatform/blob/main/.assets/_PropostaServiceAPI_swagger.PNG?raw=true)


</details>


 
<details>
	<summary># 4. ContratacaoService.Api</summary>


![ContratacaoService.Api](https://github.com/roodriiigooo/InsurancePlatform/blob/main/.assets/_ContratacaoServiceAPI_swagger.PNG?raw=true)


</details>





